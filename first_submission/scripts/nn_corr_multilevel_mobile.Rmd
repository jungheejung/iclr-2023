---
title: "iclr_corr"
author: "Heejung Jung"
date: '2022-09-14'
output:
  html_document:
    toc: true
    theme: united
    code_folding: hide
editor_options: 
  markdown: 
    wrap: 72
---

"""
This notebook examines whether the correlation coefficients between two metrics 
are statistically significant or not. 

Factors:
* performance:
1) ablation impact 
2) decoding accuracy
* metrics: 
1) cka
2) mean_cca-Corr
3) mean_sq_cca_corr
4) procrustes
5) pwcca

* linear model of correlation coefficient (different from 0), modeling random intercepts for class and layer
* I use fisher z to transform these correlation coefficients into Z vlaues (normal distribution)
* From that, we get the t-estimate, testing whether this is significant
* Afterward, I plan to convert the B0 estimate back into an r value, which is interpretable. 


TODO: concatenate all .csv files
make sure that the factor information is inserted into each 
"""
# load data
# calculate correlation
# fisher z transform 
# model mean cor value for class layer unit

```{r load libraries include=FALSE}
library(psych)
library(car)
#library(lmSupport)
library(lme4)
library(lmerTest)
library(plyr)
library(dplyr)
library(correlation)
library(ggplot2)
library(gghalves)
library(rmarkdown)
library(readr)
library(yaml)
library(tidyverse)
library(GGally)
library(DescTools)
library(ggpubr)

source('http://psych.colorado.edu/~jclab/R/mcSummaryLm.R')
source("/Users/h/Documents/projects_local/RainCloudPlots/tutorial_R/R_rainclouds.R")
source("/Users/h/Documents/projects_local/RainCloudPlots/tutorial_R/summarySE.R")
source("/Users/h/Documents/projects_local/RainCloudPlots/tutorial_R/simulateData.R")
source("https://gist.githubusercontent.com/benmarwick/2a1bb0133ff568cbe28d/raw/fb53bd97121f7f9ce947837ef1a4c65a73bffb3f/geom_flat_violin.R")
file.sources = list.files(c("/Users/h/Dropbox/projects_dropbox/social_influence_analysis/scripts/step02_R/utils"),
                          pattern="*.R", 
                          full.names=TRUE, 
                          ignore.case=TRUE)
sapply(file.sources,source,.GlobalEnv)

```
```{r}

```

```{r}
main_dir <- dirname(getwd())
model = 'mobilenet'
concat_df = data.frame()
  for (dv in c('ablation_impact_X_cka', 
               'ablation_impact_X_mean_cca_corr', 
               'ablation_impact_X_mean_sq_cca_corr',
               'ablation_impact_X_procrustes', 
               'ablation_impact_X_pwcca',
               'decoding_accuracy_delta_X_cka',
               'decoding_accuracy_delta_X_mean_cca_corr',
               'decoding_accuracy_delta_X_mean_sq_cca_corr',
               'decoding_accuracy_delta_X_procrustes', 
               'decoding_accuracy_delta_X_pwcca')) {

    if (model == "alexnet") {
      data_fname <- file.path(main_dir, 'data', model, paste0(dv, '.csv'))
    } else if (model == "mobilenet") {
      data_fname <- file.path(main_dir, 'data', model, paste0(dv, '-mobilenet.csv'))
    }
df <- read.csv(data_fname)
df$performance <- strsplit(dv, '_X_')[[1]][1]
df$metric <- strsplit(dv, '_X_')[[1]][2]
concat_df <- rbind(concat_df, df)
}
```

```{r}
# concat_df$metric[concat_df$metric == "mean_cca_corr"] <- concat_df$metric*(-1)
# concat_df$metric[concat_df$metric == "mean_sq_cca_corr"] <- concat_df$metric*(-1)

# concat_transform <- concat_df %>%
#   filter(metric == "mean_cca_corr") %>%
#   mutate(mean_cca_corr_neg= (-1)*.)
#   #summarise_all(funs(sum(.)))

concat_df = concat_df %>% mutate(corr_transform = ifelse(metric == "mean_cca_corr" | metric == "mean_sq_cca_corr", -1 * correlation, correlation))
#concat_df = concat_df %>% mutate(corr_transform = ifelse(metric == "mean_sq_cca_corr", -1 * correlation, correlation))

```

```{r}
concat_df$perf_con[concat_df$performance == "ablation_impact"] <- -0.5
concat_df$perf_con[concat_df$performance == "decoding_accuracy_delta"] <- 0.5

# concat_df$x1[concat_df$performance == "cka"] <- -0.5
# concat_df$x1[concat_df$performance == "mean_cca_corr"] <- 0.5
# concat_df$x2[concat_df$performance == "mean_sq_cca_corr"] <- -0.5
# concat_df$x2[concat_df$performance == "procrustes"] <- 0.5
# concat_df$x2[concat_df$performance == "pwcca"] <- -0.5

concat_df$perf  = factor(concat_df$performance)
concat_df$metric_ordered <- factor(concat_df$metric, 
                                   levels=c("mean_cca_corr","mean_sq_cca_corr","pwcca","cka","procrustes"))
concat_df$metric_con  = factor(concat_df$metric_ordered)

contrasts(concat_df$metric_con) = contr.helmert(5)


```

```{r}
full = lmer(corr_transform ~ perf_con * metric_con + (1|class)  + (1|layer) , data = concat_df)
summary(full)
```
```{r}
non_contrast = lmer(corr_transform ~ perf_con * factor(metric) + (1|class)  , data = concat_df)
summary(non_contrast)
```



```{r}
# barplot performance
subjectwise = classwise
subjectwise_mean = "mean_per_sub"
group_mean = "mean_per_sub_norm_mean"
iv = "perf"
ylim = c(-.5, .5)
se = "se"
subject = "class"
ggtitle = paste0(model, " :: main effect of performance across layers and classes")
legend_title = "performance"
xlab = "performance "
ylab = "correlation"
w = 5
h = 3
dv_keyword = "correlation"

classwise <- meanSummary(concat_df,
                         c(subject, iv), "correlation")
groupwise <- summarySEwithin(
  data = classwise,
  measurevar = "mean_per_sub",
  # variable created from above
  withinvars = c(iv),
  # iv
  idvar = subject
)
if (any(startsWith(dv_keyword, c("expect", "Expect")))) {
  color <- c("#1B9E77", "#D95F02")
} else {
  color <- c( "#D73027", "#4575B4")
}
g <- ggplot(data = subjectwise,
            aes(
              y = .data[[subjectwise_mean]],
              x = factor(.data[[iv]]),
              fill = factor(.data[[iv]])
            )) +
  #coord_cartesian(ylim = ylim, expand = TRUE) +
  
  # geom_flat_violin(
  #   aes(fill = factor(.data[[iv]])),
  #   position = position_nudge(x = .1, y = 0),
  #   adjust = 1.5, trim = FALSE, alpha = .3, colour = NA
  # ) +
  
  geom_half_violin(
    aes(fill = factor(.data[[iv]])),
    side = 'r',
    position = 'dodge',#position_nudge(x = .1, y = 0),
    adjust = 1.5,
    trim = FALSE,
    alpha = .3,
    colour = NA
  ) +
  
  # geom_line(
  #   data = subjectwise,
  #   aes(
  #     group = .data[[subject]],
  #     y = .data[[subjectwise_mean]],
  #     x = as.numeric(.data[[iv]]) - .15,
  #     fill = factor(.data[[iv]])
  #   ),
  #   linetype = "solid",
  #   color = "grey",
  #   alpha = .3
  # ) +
  
  geom_point(
    aes(
      x = as.numeric(.data[[iv]]) - .15,
      y = .data[[subjectwise_mean]],
      color = factor(.data[[iv]])
    ),
    position = position_jitter(width = .05),
    size = 2,
    alpha = 0.8,
    #shape = 20
  ) +
  #geom_half_boxplot(side = "r") +
  geom_half_boxplot(
    aes(x = .data[[iv]],
        y = .data[[subjectwise_mean]],
        fill = .data[[iv]]),
    side = "r",
    outlier.shape = NA,
    alpha = 0.8,
    width = .1,
    colour = "black",
    errorbar.draw = FALSE
  ) +
  # geom_errorbar(
  #   data = groupwise,
  #   aes(
  #     x = as.numeric(.data[[iv]]) + .1,
  #     y = as.numeric(.data[[group_mean]]),
  #     colour = factor(.data[[iv]]),
  #     ymin = .data[[group_mean]] - .data[[se]],
  #     ymax = .data[[group_mean]] + .data[[se]]
  #   ),
  #   width = .05,
  #   staplelwd = 0
  # ) +
  # legend stuff ________________________________________________________ # nolint
  #expand_limits(x = 2.8) +
  #guides(fill = "none") +
  guides(color = "none") +
  guides(fill = guide_legend(title = legend_title)) +
  scale_fill_manual(values = color) +
  scale_color_manual(values = color) +
  ggtitle(ggtitle) +
  xlab(xlab) +
  ylab(ylab) +
  theme_bw() + ggpubr::theme_classic2()+
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
    theme(aspect.ratio=2/3) 
#ggsave(save_fname, width = w, height = h)
g
```
```{r}


subjectwise = classwise
subjectwise_mean = "mean_per_sub"
group_mean = "mean_per_sub_norm_mean"
iv = "performance"
ylim = c(-.5, .5)
se = "se"
subject = "class"
ggtitle = "main effect of performance across layers and classes"
xlab = "performance "
ylab = "correlation"
w = 5
h = 3
dv_keyword = "performance"

j <- ggplot(data = subjectwise,
            mapping = aes(x = .data[[iv]],
                          y = .data[[subjectwise_mean]])) +
  geom_jitter(position = position_jitter(0.3),
              size = 1,
              colour = "#808080") +
  # scale_color_manual(values = c("#D3C2FF", "#7E79FF", "#0237C9")) +
  geom_pointrange(
    data = groupwise,
    mapping = aes(
      x = .data[[iv]],
      y = .data[[group_mean]],
      ymin = as.numeric(.data[[group_mean]] - .data[[se]]),
      ymax = as.numeric(.data[[group_mean]] + .data[[se]]),
      color = .data[[iv]]
    ),
    position = position_dodge(0.3),
    size = 1,
    shape = 19
  ) +
  theme_classic() +
  expand_limits(x = 3.25) +
  guides(fill = FALSE) +
  guides(color = FALSE) +
  guides(fill = guide_legend(title = "social cues")) +
  scale_fill_manual(values = color) +
  scale_color_manual(values = color) +
  xlab(xlab) +
  ylab(ylab) +
  ggtitle(ggtitle)
# ggsave(save_fname, width = w, height = h)
j

```
```{r}


df = concat_df
x_axis = "performance"
y = "mean_per_sub"
vertical = TRUE
jitter_width = 0.09
point_size = 3
violin_alpha = 0.3
boxplot_alpha = 1
side = 'r'
j <- ggplot(data = classwise,
            mapping = aes(x = .data[[iv]],
                          y = .data[[subjectwise_mean]])) +
geom_half_violin(
  data = concat_df,
  aes(x = x_axis, y = {
    {
      y
    }
  }),
  side = side,
  position = position_nudge(x = position_nudge_vector[3]),
  alpha = violin_alpha
) +
  
  geom_half_boxplot(
    data = concat_df,
    aes(x = x_axis, y = {
      {
        y
      }
    }),
    position = position_nudge(x = position_nudge_vector[2]),
    side = side,
    outlier.shape = NA,
    center = TRUE,
    errorbar.draw = FALSE,
    width = 0.2,
    alpha = boxplot_alpha,
    color = 'black'
  ) +
  
  geom_point(
    data = df,
    aes(x = as.numeric(.data[[iv]]) - .15, y = {
      {
        y
      }
    }),
    size = point_size,
    position = position_nudge(x = position_nudge_vector[1]),

  ) 
j
```



```{r}

```
```{r}
# barplot metric
metric_classwise <- meanSummary(
        concat_df,
        c("class","metric_con"), "corr_transform"
    )
metric_groupwise <- summarySEwithin(
        data = metric_classwise,
        measurevar = "mean_per_sub", # variable created from above
        withinvars = c( "metric_con"), # iv
        idvar = "class"
    )
subjectwise = metric_classwise
groupwise = metric_groupwise
subjectwise_mean = "mean_per_sub"
group_mean = "mean_per_sub_norm_mean"
iv = "metric_con"
ylim = c(0, .5)
se = "se"
subject = "class"
ggtitle = paste0(model, " :: main effect of metric across layers and classes")
legend_title = "metric"
xlab = "metric"
ylab = "correlation"
w = 5
h = 10
dv_keyword = "correlation"

if (any(startsWith(dv_keyword, c("expect", "Expect")))) {
  color <- c("#464655", "#898983","#B6B6C1", "#CECEE0", "#DEDEEF")
} else {
  color <- c( "#000000","#2D0040", "#5A0080","#8600BF","#B300FF")
}
g <- ggplot(data = subjectwise,
            aes(
              y = .data[[subjectwise_mean]],
              x = factor(.data[[iv]]),
              fill = factor(.data[[iv]])
            )) +
  geom_half_violin(
    aes(fill = factor(.data[[iv]])),
    side = 'r',
    position = 'dodge',#position_nudge(x = .1, y = 0),
    adjust = 1.5,
    trim = TRUE,
    alpha = .3,
    colour = NA
  ) +
  
  geom_point(
    aes(
      x = as.numeric(factor(.data[[iv]])) - .15 ,
      y = .data[[subjectwise_mean]],
      color = factor(.data[[iv]])
    ),
    position = position_jitter(width = .05),
    size = 2,
    alpha = 0.8,
    #shape = 20
  ) +
  
  geom_half_boxplot(
    aes(x = .data[[iv]],
        y = .data[[subjectwise_mean]],
        fill = .data[[iv]]),
    side = "r",
    outlier.shape = NA,
    alpha = 0.8,
    width = .2,
    colour = "black",
    # staplelwd = 0,
    notch = FALSE,
    notchwidth = 0,
    varwidth = FALSE, 
    errorbar.draw = FALSE
  ) +

  # geom_errorbar(
  #   data = groupwise,
  #   aes(
  #     x = as.numeric(.data[[iv]]) + .1,
  #     y = as.numeric(.data[[group_mean]]),
  #     colour = factor(.data[[iv]]),
  #     ymin = .data[[group_mean]] - .data[[se]],
  #     ymax = .data[[group_mean]] + .data[[se]]
  #   ),
  #   width = .05,
  #   staplelwd = 0
  # ) +
  # legend stuff ________________________________________________________ # nolint
  #expand_limits(x = 2.8) +
  #guides(fill = "none") +
  guides(color = "none") +
  guides(fill = guide_legend(title = legend_title)) +
  scale_fill_manual(values = color) +
  scale_color_manual(values = color) +
  ggtitle(ggtitle) +
  xlab(xlab) +
  ylab(ylab) +
  ylim(ylim) +
  
  theme_bw() + ggpubr::theme_classic2() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
    theme(aspect.ratio=4/6) 

#ggsave(save_fname, width = w, height = h)
g
```






```{r}
int_unitwise <- meanSummary(
        concat_df,
        c("class", "perf", "metric_con"), "corr_transform"
    )
int_groupwise <- summarySEwithin(
        data = int_unitwise,
        measurevar = "mean_per_sub", # variable created from above
        withinvars = c("perf", "metric_con"), # iv
        idvar = "class"
    )

```

```{r}
library(gghalves)
# barplot interaction
subjectwise = int_unitwise
groupwise = int_groupwise
iv1 = "perf"
iv2 = "metric_con" 
sub_mean = "mean_per_sub" 
group_mean = "mean_per_sub_norm_mean" 
se = "se" ; subject = "class"
ggtitle = paste0(model," :: interaction of performance and metric" )

legend_title = "metric"
xlab = "metric"
ylab = "correlation"
w = 5
h = 10
ylim = c(-.5,1)
dv_keyword = "correlation"
color = c(
  "#000000",
  "#3F0005",
  "#7D000B",
  "#BC0010",
  "#FA0015",

  "#000000",
  "#00003F",
  "#00007D",
  "#0000BC",
  "#0000FA"
)
  # decoding
g <- ggplot(data = subjectwise,
            aes(y = .data[[sub_mean]],
                x = .data[[iv1]],
                fill = .data[[iv2]],
                width=.9)) +
  coord_cartesian(ylim = ylim, expand = TRUE) +
  geom_flat_violin(
    aes(fill = .data[[iv2]]),
    position = position_nudge(x = .1, y = 0),
    adjust = 1.5,
    trim = FALSE,
    alpha = 0,
    colour = NA
  ) +
  # geom_line(
  #     data = subjectwise,
  #     aes(
  #         group = .data[[subject]],
  #         y = .data[[sub_mean]],
  #         x = as.numeric(.data[[iv1]]) - .15,
  #         fill = .data[[iv2]]
  #     ),
  #     linetype = 3, color = "grey", alpha = .3
  # ) +
  geom_point(

    data = subjectwise,
    aes(
      x = as.numeric(.data[[iv1]]),
      y = .data[[subjectwise_mean]],
      color = .data[[iv2]]
    ),
    position = position_jitterdodge(), #position_jitter(width = .05),
    size = 1,
    alpha = 0.8,
    shape = 20
  ) +
  # geom_boxplot(
  #   data = subjectwise,
  #   aes(x = .data[[iv1]],
  #       y = .data[[sub_mean]],
  #       fill = .data[[iv2]]),
  #   width = .1,
  #   outlier.shape = NA,
  #   alpha = 0.8,
  #   width = .1,
  #   colour = "black"
  # ) +
  # 
  geom_half_boxplot(
    data = subjectwise,
    aes(x = .data[[iv1]],
        y = .data[[subjectwise_mean]],
        fill = .data[[iv2]]),
    side = "r",
    outlier.shape = NA,
    alpha = 0.8,
    width = .8,
    #nudge = 0.2,
    colour = "black",
    #dodge = TRUE,
    # staplelwd = 0,
    notch = FALSE,
    notchwidth = 0,
    varwidth = FALSE,
    errorbar.draw = FALSE,
    center = TRUE
  ) +
  # use summary stats __________________________________________________________________________________ # nolint
  
  # geom_errorbar(
  #   data = groupwise,
  #   aes(
  #     x = as.numeric(.data[[iv1]]) + .1,
  #     y = .data[[group_mean]],
  #     group = .data[[iv2]],
  #     colour = .data[[iv2]],
  #     ymin = .data[[group_mean]] - .data[[se]],
  #     ymax = .data[[group_mean]] + .data[[se]]
  #   ),
  #   width = .05
  # ) +
  
  # legend stuff __________________________________________________________________________________ # nolint
  expand_limits(x = 3.25) +
  guides(fill = "none") +
  guides(color = "none") +
  guides(fill = guide_legend(title = legend_title)) +
  # geom_text()
  
  # scale_color_brewer(palette = "Dark2") +
  # scale_fill_brewer(palette = "Dark2") +
  scale_fill_manual(values = color) +
  scale_color_manual(values = color) +
  ggtitle(ggtitle) +
  # coord_flip() + #vertical vs horizontal
  xlab(xlab) +
  ylab(ylab) +
  
  theme_bw() + ggpubr::theme_classic2() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
    theme(aspect.ratio=4/6) 
g 
```
```{r}
effect size
https://stats.stackexchange.com/questions/257985/how-can-i-derive-effect-sizes-in-lme4-and-describe-the-magnitude-of-fixed-effect
```


```{r}
library(gghalves)
# barplot interaction
#alexnet_naomit <- na.omit(alexnet_corr) 
#layerwise_alex <- meanSummary(alexnet_naomit, c("layer"), "z_fisher")

# * dataset: trialorder_groupwise_p2
# * x-axis: trial_index (sorted)
# * y-axis: rating
# * group: cue_ordered, rating_type
# * DV: mean_per_sub_norm_mean
# * error bar: se

iv1 = "trial_index"
iv2 = "cue_ordered"
x = "metric"
y = "mean_per_sub_norm_mean"
violin_alpha = 0.3
boxplot_alpha = 1
sep_level= 4
    if (sep_level == 4) {
      position_nudge_vector <- c(-0.2, 0,0.2)
    } else if (sep_level == 3) {
      position_nudge_vector <- c(-0.15, 0,0.15)
    } else if (sep_level == 2) {
      position_nudge_vector <- c(-0.15,0,0)
    } else if (sep_level == 1) {
      position_nudge_vector <- c(-0.08,0,0)
    } else if (sep_level == 0) {
      position_nudge_vector <- c(0,0,0)
    }
g <- ggplot(
  data = groupwise,
  aes(x = metric,
      y = mean_per_sub_norm_mean, 

           )  ) +    
  geom_point(
    data = groupwise,
    aes(
      #shape = as.character(rating_type_key),
      x =metric,
      y = mean_per_sub_norm_mean,
      ),
    #position = position_jitter(width = .05),
    size = 2
    ) +
geom_half_violin(data = groupwise,
                       aes(x = metric, y = mean_per_sub_norm_mean), side = 'r',
                       position = position_nudge(x = position_nudge_vector[3]), alpha = violin_alpha) +

        # geom_half_violin(data = groupwise,
        #                aes(x = performance, y = mean_per_sub_norm_mean), side = 'r',
        #                position = position_nudge(x = position_nudge_vector[3]), alpha = violin_alpha) +
      geom_half_boxplot(data = groupwise,
                        aes(x = metric, y = mean_per_sub_norm_mean),
                        position = position_nudge(x = position_nudge_vector[1]),
                        side = 'r', outlier.shape = NA, center = TRUE,
                        errorbar.draw = FALSE, width = 0.2, alpha = boxplot_alpha, color = 'black') +
  scale_shape_manual(values=c(16, 21))+
geom_line()+
geom_errorbar(
  data = groupwise,
  aes(
    x = as.numeric(metric),
    y = mean_per_sub_norm_mean,
    #color = class,
    #colour = cue_ordered,
    ymin = mean_per_sub_norm_mean - se,
    ymax = mean_per_sub_norm_mean + se
    ), width = .1, size = 0.5
  ) +
          geom_point(
            data = classwise,
            aes(
                x = metric ,
                y = mean_per_sub,
                #color = performance
            ),
            position = position_jitter(width = .05),
            size = 3, alpha = 0.8, shape = 20
        ) +
geom_hline(yintercept = 0) +
        geom_line(
            data = classwise,
            aes(
                #group = class,
                y = mean_per_sub,
                x = metric,
                #fill = performance
            ),
            #linetype = 3,
              alpha = .3, width = .1
        ) +
 # scale_color_manual(values = c("high cue" = "red", 
                               # "low cue" = "blue")) +
  #xlab("layers") +
  ylab("correlation (fisher z)") +
  #ylim(0,100) +
  theme_bw() 
g 
```



# Main statistical test Question 01 :: Is this correlation significantly different from the null, i.e. 0? 
Using the fisher z transfor, we test whether tthe correlation coefficients are significantly different from 0, while modeling random intercepts in class and layers (allowing for class and layers to have different "mean" coefficients).
```{r}
main_dir <- dirname(getwd())
for (model in c('alexnet', 'mobilenet')) {
  analysis_dir <- file.path(main_dir, 'results', model, as.character(Sys.Date()))
  dir.create(analysis_dir, showWarnings = FALSE, recursive = TRUE)
  statsummary_fname <- file.path(
            analysis_dir,
            paste('statsummary_model-', model,
                '_', as.character(Sys.Date()), '.txt',
                sep = ""
            )
        )
  if (file.exists(statsummary_fname)) {
      file.remove(statsummary_fname)
  }

  statsummary <- ""
  for (dv in c('ablation_impact_X_cka', 
               'ablation_impact_X_decoding_accuracy_delta',
               'ablation_impact_X_mean_cca_corr', 
               'ablation_impact_X_mean_sq_cca_corr',
               'ablation_impact_X_procrustes', 
               'ablation_impact_X_pwcca',
               'decoding_accuracy_delta_X_cka',
               'decoding_accuracy_delta_X_mean_cca_corr',
               'decoding_accuracy_delta_X_mean_sq_cca_corr',
               'decoding_accuracy_delta_X_procrustes', 
               'decoding_accuracy_delta_X_pwcca')) {
    # load data per metric
    if (model == "alexnet") {
      data_fname <- file.path(main_dir, 'data', model, paste0(dv, '.csv'))
    } else if (model == "mobilenet") {
      data_fname <- file.path(main_dir, 'data', model, paste0(dv, '-mobilenet.csv'))
      }
  
    df <- read.csv(data_fname)
    df$fisherZ <- DescTools::FisherZ(df$correlation)
    model_cor <- lmer(fisherZ ~ 1 + (1|class) + (1|layer) , data = df)
    model_savefname <- file.path(
            analysis_dir,
            paste('lmer_model-', model,
                '_dv-', dv,
                '_', as.character(Sys.Date()), '.txt',
                sep = ""
            )
        )
  if (file.exists(model_savefname)) {
      file.remove(model_savefname)
  }
    sink(file = model_savefname)
    s <- summary(model_cor)
    capture.output(s, file = model_savefname)
    stats <- paste0('b = ',round(summary(model_cor)$coefficients[1], digits = 3), ', ',
          't(', round(summary(model_cor)$coefficients[3], digits = 2), ') = ',
          round(summary(model_cor)$coefficients[4], digits = 3),', ',
          'p = ',round(summary(model_cor)$coefficients[5],digits = 4))
    print(stats)
    sink(file = NULL)
    
    statsummary <- paste0(statsummary, '\n', '* metric: ', dv, '  >>>   stats: ', stats, '\n')
  }
  sink(file = statsummary_fname)
  # print(cat(statsummary))
  capture.output(cat(statsummary), file = statsummary_fname)
  sink(file = NULL)


}
```

# filename
# ablation_impact X cka

```{r load data}

data_fname = file.path(main_dir, 'data', model, paste0('ablation_impact_X_cka', '.csv'))
alexnet = read.csv(data_fname)
```
arise(cor = cor(decoding_accuracy_delta,ablation_impact))

```{r fisher z transform}
# fisher z transform
alexnet$fisherZ = DescTools::FisherZ(alexnet$correlation)

```


```{r}
model_cor = lmer(fisherZ ~ 1 + (1|class) + (1|layer) , data = alexnet)
model_savefname <- file.path(
        analysis_dir,
        paste('lmer_model-', model,
            '_dv-', dv,
            '_', as.character(Sys.Date()), '.txt',
            sep = ""
        )
    )
sink(file = model_savefname)
summary(model_cor)
paste0('b = ',round(summary(model_cor)$coefficients[1], digits = 3), ', ',
      't(', round(summary(model_cor)$coefficients[3], digits = 2), ') = ',
      round(summary(model_cor)$coefficients[4], digits = 3),', ',
      'p = ',round(summary(model_cor)$coefficients[5],digits = 4))
sink(file = NULL)

```


# covert estimate fisherz to r
```{r}
FisherZInv(0.19015)

```



